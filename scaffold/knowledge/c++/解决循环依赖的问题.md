要解决 **`Mat`（矩阵）、`Eul`（欧拉角）、`Quat`（四元数）三者互相转化**（共6个转换函数）的模板类依赖问题，核心是**分层前向声明 + 分离实现 + 主头文件顺序控制**，确保循环依赖被打破，同时保持模板的灵活性。以下是具体方案：


## **一、明确转换函数与依赖链**
首先梳理**6个转换函数**及依赖关系：
1. **`Mat → Quat`**：矩阵转四元数（`Mat::toQuat()`）  
2. **`Mat → Eul`**：矩阵转欧拉角（`Mat::toEul<Order>()`）  
3. **`Quat → Mat`**：四元数转矩阵（`Quat::toMat()` 或 `Mat::fromQuat()`）  
4. **`Quat → Eul`**：四元数转欧拉角（`Quat::toEul<Order>()`）  
5. **`Eul → Mat`**：欧拉角转矩阵（`Eul::toMat()` 或 `Mat::fromEul()`）  
6. **`Eul → Quat`**：欧拉角转四元数（`Eul::toQuat()`）  

依赖链：  
`Mat` ↔ `Quat` ↔ `Eul`（三者互相依赖）


## **二、解决方案：前向声明 + 分离实现**
通过**前向声明**允许跨文件声明转换函数，通过**`.cpp` 文件实现**解决完整类型依赖，最终通过**主头文件顺序**确保用户使用时所有类型已定义。


### **1. 基础准备：`Vec` 类（无依赖）**
`Vec` 是所有类的基础（如矩阵的行向量、四元数的虚部存储），需先定义：
```cpp
// math/vec.hpp：向量类（无依赖）
#pragma once
#include <array>
#include <cmath>

namespace cgm::math {
template <typename T, size_t N>
class Vec {
public:
    using value_type = T;
    std::array<T, N> data_;

    Vec() : data_{} {}
    explicit Vec(const std::array<T, N>& arr) : data_(arr) {}

    const T& operatorsize_t i const { 
        if (i >= N) throw std::out_of_range("Vec index out of range");
        return data_[i]; 
    }
    T& operatorsize_t i { 
        if (i >= N) throw std::out_of_range("Vec index out of range");
        return data_[i]; 
    }
};
} // namespace cgm::math
```


### **2. `Mat` 类：前向声明 `Quat`/`Eul` + 声明转换函数**
`Mat` 依赖 `Vec`，并需声明到 `Quat`/`Eul` 的转换函数：
```cpp
// math/mat.hpp：矩阵类头文件
#pragma once
#include "math/vec.hpp"  // 依赖 Vec

// ------------------------------
// 前向声明：Quat 和 Eul（带模板参数）
// ------------------------------
namespace cgm::math {
template <typename U>
class Quaternion;  // 四元数

template <typename V, typename OrderT>
class EulerAngle;  // 欧拉角（OrderT 是旋转顺序）
} // namespace cgm::math

namespace cgm::math {
template <typename T, size_t N>
class Mat {
public:
    Mat() : data_{} {}  // 默认零矩阵

    // ------------------------------
    // 转换函数声明（不实现）
    // ------------------------------
    // 1. 矩阵 → 四元数
    Quaternion<T> toQuat() const;

    // 2. 矩阵 → 欧拉角（指定旋转顺序）
    template <typename OrderT>
    EulerAngle<T, OrderT> toEul() const;

private:
    std::array<Vec<T, N>, N> data_;  // 行向量数组（N=3 时是 3x3 矩阵）
};
} // namespace cgm::math
```


### **3. `Quat` 类：前向声明 `Mat`/`Eul` + 声明转换函数**
`Quat` 依赖 `Mat`（如四元数转矩阵），并需声明到 `Eul` 的转换函数：
```cpp
// math/quat.hpp：四元数类头文件
#pragma once
#include "math/vec.hpp"  // 依赖 Vec（存储虚部）

// ------------------------------
// 前向声明：Mat 和 Eul
// ------------------------------
namespace cgm::math {
template <typename U, size_t M, size_t K>
class Mat;  // 矩阵

template <typename V, typename OrderT>
class EulerAngle;  // 欧拉角
} // namespace cgm::math

namespace cgm::math {
template <typename T>
class Quaternion {
public:
    Quaternion() : w_(1), x_(0), y_(0), z_(0) {}  // 默认单位四元数

    // ------------------------------
    // 转换函数声明（不实现）
    // ------------------------------
    // 3. 四元数 → 矩阵
    Mat<T, 3, 3> toMat() const;

    // 4. 四元数 → 欧拉角（指定旋转顺序）
    template <typename OrderT>
    EulerAngle<T, OrderT> toEul() const;

private:
    T w_, x_, y_, z_;  // 四元数数据（w + xi + yj + zk）
};
} // namespace cgm::math
```


### **4. `Eul` 类：前向声明 `Mat`/`Quat` + 声明转换函数**
`Eul` 依赖 `Mat`（如欧拉角转矩阵）和 `Quat`（如欧拉角转四元数），并需声明到 `Mat`/`Quat` 的转换函数：
```cpp
// math/eul.hpp：欧拉角类头文件
#pragma once
#include "math/vec.hpp"  // 依赖 Vec（存储角度）

// ------------------------------
// 前向声明：Mat 和 Quat
// ------------------------------
namespace cgm::math {
template <typename U, size_t M, size_t K>
class Mat;  // 矩阵

template <typename V>
class Quaternion;  // 四元数
} // namespace cgm::math

namespace cgm::math {
// 欧拉角旋转顺序枚举（示例）
enum class RotationOrder { RollPitchYaw, YawPitchRoll, AxisAngle };

template <typename T, typename OrderT = RotationOrder::RollPitchYaw>
class EulerAngle {
public:
    EulerAngle() : roll_(0), pitch_(0), yaw_(0) {}  // 默认零角

    // ------------------------------
    // 转换函数声明（不实现）
    // ------------------------------
    // 5. 欧拉角 → 矩阵
    Mat<T, 3, 3> toMat() const;

    // 6. 欧拉角 → 四元数
    Quaternion<T> toQuat() const;

private:
    T roll_, pitch_, yaw_;  // 欧拉角（Roll-Pitch-Yaw）
};
} // namespace cgm::math
```


### **5. 实现转换函数：`.cpp` 文件包含依赖头文件**
每个类的转换函数实现需放在 `.cpp` 文件中，并**包含所需的其他类头文件**，以获取完整类型定义。


#### **`mat.cpp`：实现 `Mat` 的转换函数**
```cpp
#include "math/mat.hpp"
#include "math/quat.hpp"  // 需要 Quat 的完整定义
#include "math/eul.hpp"   // 需要 Eul 的完整定义

namespace cgm::math {
// ------------------------------
// Mat → Quat：矩阵转四元数（3x3 旋转矩阵）
// ------------------------------
template <typename T>
Quaternion<T> Mat<T, 3, 3>::toQuat() const {
    T trace = data_[0][0] + data_[1][1] + data_[2][2];
    Quaternion<T> quat;

    if (trace > T(0)) {
        T s = std::sqrt(trace + T(1)) * T(2);
        quat.w_ = T(0.25) * s;
        quat.x_ = (data_[2][1] - data_[1][2]) / s;
        quat.y_ = (data_[0][2] - data_[2][0]) / s;
        quat.z_ = (data_[1][0] - data_[0][1]) / s;
    } else {
        // 处理 trace ≤ 0 的情况（略）
    }
    return quat;
}

// ------------------------------
// Mat → Eul：矩阵转欧拉角（Roll-Pitch-Yaw 顺序）
// ------------------------------
template <typename T>
EulerAngle<T, RotationOrder::RollPitchYaw> Mat<T, 3, 3>::toEul() const {
    EulerAngle<T, RotationOrder::RollPitchYaw> eul;
    eul.pitch_ = std::asin(-data_[2][0]);
    eul.yaw_ = std::atan2(data_[1][0], data_[0][0]);
    eul.roll_ = std::atan2(data_[2][1], data_[2][2]);
    return eul;
}

// 显式实例化常用类型（如 float）
template class cgm::math::Mat<float, 3>;
} // namespace cgm::math
```


#### **`quat.cpp`：实现 `Quat` 的转换函数**
```cpp
#include "math/quat.hpp"
#include "math/mat.hpp"  // 需要 Mat 的完整定义
#include "math/eul.hpp"   // 需要 Eul 的完整定义

namespace cgm::math {
// ------------------------------
// Quat → Mat：四元数转矩阵（3x3 旋转矩阵）
// ------------------------------
template <typename T>
Mat<T, 3, 3> Quaternion<T>::toMat() const {
    Mat<T, 3, 3> mat;
    T xx = x_ * x_, yy = y_ * y_, zz = z_ * z_;
    T xy = x_ * y_, xz = x_ * z_, yz = y_ * z_;
    T wx = w_ * x_, wy = w_ * y_, wz = w_ * z_;

    mat(0,0) = 1 - 2*(yy + zz); mat(0,1) = 2*(xy - wz); mat(0,2) = 2*(xz + wy);
    mat(1,0) = 2*(xy + wz); mat(1,1) = 1 - 2*(xx + zz); mat(1,2) = 2*(yz - wx);
    mat(2,0) = 2*(xz - wy); mat(2,1) = 2*(yz + wx); mat(2,2) = 1 - 2*(xx + yy);
    return mat;
}

// ------------------------------
// Quat → Eul：四元数转欧拉角（Roll-Pitch-Yaw 顺序）
// ------------------------------
template <typename T>
EulerAngle<T, RotationOrder::RollPitchYaw> Quaternion<T>::toEul() const {
    EulerAngle<T, RotationOrder::RollPitchYaw> eul;
    eul.roll_ = std::atan2(
        2*(w_*x_ + y_*z_), 
        1 - 2*(x_*x_ + y_*y_)
    );
    eul.pitch_ = std::asin(
        2*(w_*y_ - z_*x_)
    );
    eul.yaw_ = std::atan2(
        2*(w_*z_ + x_*y_), 
        1 - 2*(y_*y_ + z_*z_)
    );
    return eul;
}

// 显式实例化常用类型（如 float）
template class cgm::math::Quaternion<float>;
} // namespace cgm::math
```


#### **`eul.cpp`：实现 `Eul` 的转换函数**
```cpp
#include "math/eul.hpp"
#include "math/mat.hpp"  // 需要 Mat 的完整定义
#include "math/quat.hpp" // 需要 Quat 的完整定义

namespace cgm::math {
// ------------------------------
// Eul → Mat：欧拉角转矩阵（Roll-Pitch-Yaw 顺序）
// ------------------------------
template <typename T, typename OrderT>
Mat<T, 3, 3> EulerAngle<T, OrderT>::toMat() const {
    Mat<T, 3, 3> mat;
    T cr = std::cos(roll_), sr = std::sin(roll_);
    T cp = std::cos(pitch_), sp = std::sin(pitch_);
    T cy = std::cos(yaw_), sy = std::sin(yaw_);

    mat(0,0) = cr*cp*cy - sr*sp*sy;
    mat(0,1) = -cr*cp*sy - sr*sp*cy;
    mat(0,2) = cr*sp;
    mat(1,0) = sr*cp*cy + cr*sp*sy;
    mat(1,1) = -sr*cp*sy + cr*sp*cy;
    mat(1,2) = sr*sp;
    mat(2,0) = -cp*sy;
    mat(2,1) = cp*cy;
    mat(2,2) = sp*sp + cp*cp*cy*cy; // 简化示例，实际需完整计算
    return mat;
}

// ------------------------------
// Eul → Quat：欧拉角转四元数（Roll-Pitch-Yaw 顺序）
// ------------------------------
template <typename T, typename OrderT>
Quaternion<T> EulerAngle<T, OrderT>::toQuat() const {
    T cy = std::cos(yaw_ * T(0.5));
    T sy = std::sin(yaw_ * T(0.5));
    T cp = std::cos(pitch_ * T(0.5));
    T sp = std::sin(pitch_ * T(0.5));
    T cr = std::cos(roll_ * T(0.5));
    T sr = std::sin(roll_ * T(0.5));

    return Quaternion<T>{
        cr*cp*cy + sr*sp*sy,
        sr*cp*cy - cr*sp*sy,
        cr*sp*cy + sr*cp*sy,
        cr*cp*sy - sr*sp*cy
    };
}

// 显式实例化常用类型（如 float）
template class cgm::math::EulerAngle<float, RotationOrder::RollPitchYaw>;
} // namespace cgm::math
```


### **6. 主头文件：按依赖顺序包含**
主头文件（`cgm/math.hpp`）按**基础 → 高级**的顺序包含子模块，确保用户使用时所有类型已定义：
```cpp
// cgm/math.hpp：CGM 主入口头文件
#pragma once

// 1. 基础类型：向量（无依赖）
#include "math/vec.hpp"

// 2. 依赖向量的类型：矩阵
#include "math/mat.hpp"  // Mat 依赖 Vec

// 3. 依赖矩阵的类型：四元数
#include "math/quat.hpp" // Quat 依赖 Mat

// 4. 依赖矩阵和四元数的类型：欧拉角
#include "math/eul.hpp"  // Eul 依赖 Mat 和 Quat
```


## **三、使用示例：用户只需包含主头文件**
使用者只需包含 `cgm/math.hpp`，即可调用所有转换函数：
```cpp
#include "cgm/math.hpp"  // 唯一需要包含的文件

int main() {
    using namespace cgm::math;
    using RotationOrder = RotationOrder;

    // ------------------------------
    // 1. 矩阵 → 四元数
    // ------------------------------
    Mat<float, 3, 3> rotMat = {
        {{0.866f, 0, 0.5f}, {0, 1, 0}, {-0.5f, 0, 0.866f}} // 绕 Y 轴旋转 30°
    };
    Quaternion<float> quat = rotMat.toQuat();

    // ------------------------------
    // 2. 矩阵 → 欧拉角
    // ------------------------------
    EulerAngle<float, RotationOrder::RollPitchYaw> eulFromMat = rotMat.toEul();

    // ------------------------------
    // 3. 四元数 → 欧拉角
    // ------------------------------
    EulerAngle<float, RotationOrder::RollPitchYaw> eulFromQuat = quat.toEul();

    // ------------------------------
    // 4. 欧拉角 → 矩阵
    // ------------------------------
    EulerAngle<float, RotationOrder::RollPitchYaw> eul(0.1f, 0.2f, 0.3f);
    Mat<float, 3, 3> matFromEul = eul.toMat();

    return 0;
}
```


## **四、关键优化：显式实例化**
在 `.cpp` 文件中**显式实例化常用类型**（如 `Mat<float,3>`、`Quaternion<float>`），避免用户重复实例化，提升编译效率：
```cpp
// mat.cpp 末尾
template class cgm::math::Mat<float, 3>;

// quat.cpp 末尾
template class cgm::math::Quaternion<float>;

// eul.cpp 末尾
template class cgm::math::EulerAngle<float, RotationOrder::RollPitchYaw>;
```


## **